# Leetcode-Learnings

## My mistakes and learnings

| # | Summary | Comments | References |
|---|---------|----------|------------|
| 1 | Efficient operations based on if input from a stream or a list | - Better to do sort on the complete list <br> - If possible do bucket sort for input from a stream <br> - Basically, see how you can optimize for these two scenarios | [Minimum Time Difference - Bucket Sort](Algorithms/Minimum%20Time%20Difference%20-%20Bucket%20Sort.py) |
| 2 | If the size of a data structure is fixed, consider array too instead of using a general data structure | - Had to implement a Deque with fixed size <br> I choose the data structure as a double ended linked list <br> - It was correct, but since the size is fixed, can also use an array <br> - Keep an eye out for a simple solution rather than a general one | [Circular Deque](./Data%20Structures/Circular%20Deque.py) | 
| 3 | Rain water problems mostly can be solved with Two pointers | - I solved it using monotonic stack, which was also good <br> - There was a two pointer solution which was more amazing<br> - Column wise adding the water and row wise adding the water | 1. [Trapping Rain Water](./Two%20Pointers/Trapping%20Rain%20Water.py) <br>2. [Trapping Rain Water - Monotonic Stack](./Monotonic%20Stack/Trapping%20Rain%20Water.py) |
| 4 | Palindrome questions, Inwards from the end or Outwards from the center | - I struggled with the expanding from the center for this question, but coming inwards from the ends was way too easy. | [Valid Palindrome II](./Palindrome/Valid%20Palindrome%20II.py) 
| 5 | Equation logic of two-sum, i+j=target <br> i = target - j <br> Find if there was such i <br> | - Can be used in general problems involving two iterations and getting a fixed value, usually going O(N^2) because of two loops <br>- By checking if the previous was there or not in a hashmap helps <br>- In this problem, was used with a prefix sum, a crazy problem | 1. [Make Sum divisible by p](./Prefix%20Sum/Make%20Sum%20divisible%20by%20p.py) <br> 2. [Continuous Subarray Sum](./HashMaps/Continuous%20Subarray%20Sum.py)
| 6 | Think about prefix and suffixes in sentences too | - Idiotically tried a hashset solution here <br> - Prefix Suffix logic was so clean <br> - Need to actively think about these | [Sentence Similarity III](./String%20Manipulations/Sentence%20Similarity%20III.py)
| 7 | Using Generators in Python | - Crazy good if you want to keep the state of the function and also return something out of it <br> - Makes the code more manageable and clean <br> - Useful to create an iterator object | 1. [Nested List Weight Sum](./Generators/Nested%20List%20Weight%20Sum.py) <br> 2. [Flatten Nested List Iterator](./Stack%20/Flatten%20Nested%20List%20Iterator.py) <br> 3. [Smallest Range covering k lists](./Heaps/Smallest%20Range%20covering%20elements%20from%20k%20lists.py)
| 8 | Utilizing constriants to use Greedy approach <br> Reduced complexity from O(N^2) to O(N) | - I implemented this problem using O(N^2) loops, meanwhile a crazy greedy approach existed <br> - It utilized the constraint that we wanted the rightmost larger number, and the leftmost smaller one <br> - In one iteration, we can figure this out | [Maximum Swap](./String%20Manipulations/Maximum%20Swap.py) 
| 9 | Truncate division towards zero <br> use int(a/b) <br> // and math.floor truncates towards - infinity | - I used math.floor here, but -1.5 truncates to -2. I wanted -1. <br> - For this, use int(a/b) or math.trunc(a/b) | [Basic Calculator II](./String%20Manipulations/Basic%20Calculator%20II.py)
| 10 | While dealing with reverse expressions, remember to reverse the numbers that are formed <br> Take comprehensive test cases, forgot to take 2 digit numbers | - For this problem, I reversed the expression <br> - After forming the numbers, I was directly appeding it, forgot to reverse the number formed <br> - Always take good test cases, forgot to consider two digit numbers | [Basic Calculator](./String%20Manipulations/Basic%20Calculator.py)
| 11 | Recursive solution is top down, iterative solution is bottom up, atleast in this case | - I solved it using a recursive approach <br> - The iterative approach is also so simple using a stack and starting from the bottom up | [Evaluate Reverse Polish Notation](./String%20Manipulations/Evaluate%20Reverse%20Polish%20Notation.py)
| 12 | Finding if two intervals intersect | - end1 >= start2 <br> - end2 >= start1 | [Interval List Intersections](./Interval%20problems/Interval%20List%20Intersections.py)
| 13 | Modulus behavior of python <br> a%b has the same sign as b | - a%b gives the result with the same sign as b <br> - If b is negative, then the result will be negative <br> If b is positive, then the result will be positive <br> - -1%26 = 25 | [Group Shifted Strings](./Maths/Group%20Shifted%20Strings.py) <br> [Rotary Clock](./Assessment%20questions/Meta/Level%201/Rotary%20Clock.py)
| 14 | Good practice for division operation | - Trick was to consider only k+1 block <br> - Also to find the number of spaces remaining <br> - (a-b) gives the number of spaces with one of a and b included <br> - (a-b-1) gives the number of spaces between these two numbers <br> - (a-b+1) gives the number of spaces including these two numbers | [Cafeteria](./Assessment%20questions/Meta/Level%201/Cafeteria.py)
| 15 | Read the question and test on sample input first <br> Used a HashMap earlier, but had to use a Set | - Here, had to keep a track of the last k dishes eaten, not the last k dishes <br> - Used a HashMap to maintain the counts, but instead had to just maintain the type of dishes eaten, by a HashSet | [Kaitenzushi](./Assessment%20questions/Meta/Level%201/Kaitenzushi.py)
| *16* | Double heap for the median <br> Double heaps, please don't .pop(), use heappop() | - Use heappop and don't use pop, please! <br> - Always heappush first and then heappop while adding <br> - Keep a bal variable <br> - for lazy removal, maintain a HashMap <br> - call make_top_ready before accessing the top element to guarantee you are using a valid number from the heap | 1. [Sliding Window Median](./Heaps/Sliding%20Window%20Median.py) <br> 2. [The Number of the Smallest Unoccupied Chair](./Heaps/The%20Number%20of%20the%20Smallest%20Unoccupied%20Chair.py) <br>3. [Smallest Range Covering elements from k lists](./Heaps/Smallest%20Range%20covering%20elements%20from%20k%20lists.py)
| 17 | mid = (left+right) // 2 -> Left mid for even cases <br> mid = (left+right+1)//2 -> Right mid for even cases | - Main edge case to consider for these problems is with two elements having same values <br> - Also consider the case for empty array | [bisect_left_right](./Binary%20Search/bisect_left_right.py)
| 18 | Circular linked list insertion, insert at the drop test |  - Test cases I considered were good <br> - No list, 1 element, insert at the end | [Insert into a Sorted Circular LL](./Linked%20Lists/Insert%20into%20a%20Sorted%20Circular%20Linked%20List.py)
| 19 | When updating both next and previous of a node for a circular linked list, <br> iterate with curr and prev pointer, and create the links one way. <br> Don't complicate by creating both links for the node. <br> Create one link for each prev and curr | - In this question, I had to create a DLL from a BST <br> - My approach was correct, thinking of inorder <br> - I messed up by building both link for a node, which complicated things <br> - Instead maintaining a prev and a curr, and updating one link each pointer was way too easy <br> - Think about curr and prev when building two way, don't complicate by building both links for each node | [Convert Binary Tree to Sorted Doubly Linked List](./BST%20problems/Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List.py)
| 20 | a - b, does not consider b in the inclusive <br> a - b + 1, considers both in the inclusive <br> a-b-1, does not consider any in the inclusive <br> Also remember to convert string to int after the split | - For this question, needed to test on the inclusive part for the end time <br> - End time was included in the programs execution <br> - Nice question to test the inclusive ranges <br> - forgot to convert the string numbers to int | [Exclusive Time of Functions](./Stack%20/Exclusive%20Time%20of%20Functions.py)
| 21 | Comparing only the min and max was a better way than comparing for all | - I had a feeling that I'm wasting some unnecessary time <br> - Instead of comparing all the strings, I could have compared the min and the max only <br> - Better time complexity | [Longest Common Prefix](./String%20Manipulations/Longest%20Common%20Prefix.py)
| 22 | If merging on a common thing between two nodes <br> Think about DSU <br> parents - total number of nodes before merging | - I solved this question without DSU, but felt it was not optimized <br> - I was finding all the common sets and then merging them, and then removing them with O(N) complexity <br> - with DSU path compression and ranking, it can be done in O(1) <br> - Thus if you see any merge operation with common elements, think about DSU | [Accounts merge](./DSU/Accounts%20Merge.py)
| 23 | Remember to write self in class functions signature | - You are forgetting to write the self keyword in class function signature as well as when you are calling the functions in the class functions | [DSU](./Data%20Structures/DSU.py)
| 24 | I could swap if its not equal to val to the left <br> Better than swapping if its equal to val to the right | - In the end I wanted the k counts <br> - It makes it very easy to swap to the left instead of right | [Remove Element](./Array%20Manipulations/Remove%20Element.py)
| 25 | Using key in min function | - I used two variables diff and closest <br> When the value was less than diff, I was updaing the closest <br> - Pythonic way is to use key | [Closest Binary Search Tree value](./BST%20problems/Closest%20Binary%20Search%20Tree%20value.py)
| 26 | if not val: <br> This is true for None AS WELL AS 0 and "" <br> Be careful | - In this question, I initialized an iterator and on the condition that iterator returned None, I was returning the ans <br> - When the iterator returned 0, the program was ending | [Smallest Range covering elements from k lists](./Heaps/Smallest%20Range%20covering%20elements%20from%20k%20lists.py)
| 27 | XOR gives 0 for same and 1 for different | - XOR can be used to count even or odd elements <br> - For even, XOR would give 0, for odd XOR would give 1 | [Find the Longest Substring Containing Vowels in Even Counts](./Bitwise%20manipulation/Find%20the%20Longest%20Substring%20Containing%20Vowels%20in%20Even%20Counts.py)
| 28 | n-1 flips the least significant 1 to 0 <br> n&n-1 removes the least significant 1 | - Counting the number of 1s in the number | 1. [Number of 1 bits](./Bitwise%20manipulation/Number%20of%201%20Bits.py) <br> 2. [Power of 2](./Bitwise%20manipulation/Power%20of%202.py)
| 29 | Think about backtracking when the constraints are low<br> Optimize by pruning | - I initially though of a greedy approach, but I should have noticed the constraints <br> - The constraints were low, and backtracking was a good approach <br> - Further optimization is possible with a good pruning technique | [Split a String Into the Max Number of Unique Substrings](./Backtracking/Split%20a%20String%20Into%20the%20Max%20Number%20of%20Unique%20Substrings.py)
| 30 | Needed to maintain the window in sorted order <br> We can use a self balancing binary search tree <br> We can use bucket sort | - Needed to use a sliding window technique <br> - Needed the window in sorted order and maintain it <br> - We can use a self balancing BST or bucket sort for this | [Contains Duplicate III](./Sliding%20Window/Contains%20Duplicate%20III.py)
| 31 | For rotation, try to append the original to itself and check if it exists or not | - Slicing operator takes O(N) time <br> - Deque is not hashable object <br> - For rotation, append the original to itself and check if the goal exists or not | [Rotate String](./String%20Manipulations/Rotate%20String.py)
| 32 | Try to avoid the slicing operator on the string while a backtracking or memoization approach<br> Also, always use @cache when you are returning some value from the function | - slicing operators are O(N) <br> - Instead, use two indexes you dumbass | [Valid Palindrome III](./Palindrome/Valid%20Palindrome%20III.py)
| 33 | Check if the bisect functions returns an index which is outside the length of the array | - I forgot here to check if the index of the bisect functions is within the array <br> - This failed one of the test case | [Prime suboperations](./Maths/Prime%20Suboperations.py)
| 34 | Calculating the total number of pairs that are not connected | - I figured the DSU solution, got the number of nodes in each of the components <br> - For getting the number of pairs, I had a nested loop <br> - A better way to do this is to consider one component and all the other components as a whole, considering the total size <br> - Once that component was processed, don't consider this component's nodes for other pairs | [Count Unreachable Pairs of Nodes in an Undirected Graph](./DSU/Count%20Unreachable%20Pairs%20of%20Nodes%20in%20an%20Undirected%20Graph.py)

## Patterns in problems you just need to know

| # | Summary | Comments | References |
|---|---------|----------|------------|
| 1 | Getting the next permutation of a string | - Start from the back of the string to get the char which is not in increasing order <br> - Find the character to the right of it which is just greater than that character <br> - Swap these two <br> - Reverse all the characters after the char we just found not in increasing order to start from the start | [Next Permutation](./String%20Manipulations/Next%20Permutation.py)
| 2 | Maximum brackets that can be balanced with one swap is 2 | - Example, ]][[ -> [][] <br> - Minimum swaps needed would be number of math.ceil(mismatches/2) | [Minimum Number of Swaps to Make the String Balanced](./String%20Manipulations/Minimum%20Number%20of%20Swaps%20to%20Make%20the%20String%20Balanced.py)
| 3 | Interesting iterative solution as well as binary search | - Iterative solution: if num > k, then k is the ans. Else increment k. <br> - Binary search: val - (i+1) gives the total number of missing numbers before that index | [kth missing positive number](./Binary%20Search/kth%20missing%20positive%20number.py)
| 4 | Storing the FIRST occurrence of the invalid state | - Storing the occurrence of the first invalid state observed, and then using that to get the longest valid substring <br> - God damn good question <br> - Possibly the best | [Find the Longest Substring Containing Vowels in Even Counts](./Bitwise%20manipulation/Find%20the%20Longest%20Substring%20Containing%20Vowels%20in%20Even%20Counts.py)
| 5 | If you think KMP is hard, <br> Try KMP on a tree and LL | - Generate the lps array using a LL <br> - Match the characters in a tree | [KMP on LL and Tree](./Algorithms/KMP%20on%20LL%20and%20Tree.py)
| 6 | Binary search to find the leftmost element to start a range of k elements | - I was mind blown by this variation of the binary search <br> - They used the comparison of mid and mid+l element, and shifted the left and right on basis of that <br> - Absolutely amazing | [Find K Closest Elements](./Binary%20Search/Find%20K%20Closest%20Elements.py)
| 7 | Crazy backtracking with operators | - When binary operators are there, try to do the operation on the first element seperately <br> - When backtracking for numbers, check if it is not starting with a 0 <br> - try to keep the backtracking function simple and pass only the required things | [Expression Add Operators](./Backtracking/Expression%20Add%20Operators.py)
| 8 | Digits pattern in numbers | 1-9 9 digits <br> 10-99 90 * 2 digits<br>100-999 900 * 3 digits<br>1000-9999 9000 * 4 digits | [Nth Digit](./Maths/Nth%20digit.py)
| 9 | Median of two sorted arrays | 1. A merged array would have the length of m+n <br> 2. Getting the median of this merged array would be like creating two partitions each of almost similar lengths <br> 3. If m+n is odd, need to create partitions of length (m+n)//2 <br> 4. If the partition is proper, the median would be min(rightA,rightB) <br> 5. If m+n is even, need to create partitions of length (m+n)//2 <br> 6. If the partition is proper, the median would be (max(leftA,leftB) + min(rightA,rightB))/2 <br> 7. To make the parition proper, follow the below rules <br> 8. If leftA > rightB, need less elements of A, so move the right to the mid <br> 9. If leftB > rightA, need more elements of A, so move the left to the mid <br> | [Median of Two Sorted Arrays](./Binary%20Search/Median%20of%20Two%20Sorted%20Arrays.py)
| 10 | Create a new intermediate representation to make the graph <br> Better than making the complete graph in O(N^2) | - I made the complete graph with O(N^2) complexity <br> - There is a trick to link the nodes using a new intermediate representation | [Word Ladder](./BFS%20-%20DFS/Word%20Ladder.py) 
| 11 | The values converges to a value in the matrix | - Even though the mid value is not in the matrix when we start it, after the convergence, the l and r converges to a valid value in the matrix <br> - Here, l and r are min and max values of the matrix | [Kth Smallest Element in a Sorted Matrix](./Binary%20Search/Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.py)
| 12 | Try framing the question differently <br> Instead of incrementing k-1 elements, decrement that one element | - I surprisingly got this logic while solving <br> Other than that, there was no way dude | [Minimum Moves to Equal Array Elements](./Array%20Manipulations/Minimum%20Moves%20to%20Equal%20Array%20Elements.py)
| 13 | Getting the max and min in a window with O(1) <br> As well as maintaining it with sliding window | - This was possible due to the nature of the problem <br> - Since the order mattered here, we implemented using 2 dequeues <br> - max_queue and min_queue, where the last element holds the respective position <br> - For the sliding check, we check the left of the queue and pop the values if it matches the number pointed by the left pointer <br> - We then increment l | [Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit](./Sliding%20Window/Longest%20Continuous%20Subarray%20With%20Absolute%20Diff%20Less%20Than%20or%20Equal%20to%20Limit.py)
| 14 | Converted to a sliding window | - Naturally, this problem was not to be solved by a sliding window approach <br> - Had to tweak the problem description a bit to use sliding window <br> - You require a condition on the basis of which to shift the l | [Longest Substring with At Least K Repeating Characters](./Sliding%20Window/Longest%20Substring%20with%20At%20Least%20K%20Repeating%20Characters.py)
| 15 | Parantheses questions | - Stack solution <br> - two passes solution | [Longest valid Parantheses](./String%20Manipulations/Parantheses%20questions/Longest%20Valid%20Parentheses.py)
| 16 | Finding primes in a small range efficiently | - Creating an array till the max number of elements <br> - Iterating the array and marking each of the composites to be not prime <br> - Marking from i*i and incrementing by i | [Prime Suboperations](./Maths/Prime%20Suboperations.py)
| 17 | Counting total nodes in a complete tree | - Traverse the tree first to the left and then all the way to the right <br> - If the heights are the same, return 2^height-1 <br> - Else, do the same with adding 1 to left and right | [Count complete tree nodes](./Tree%20problems/Count%20complete%20tree%20nodes.py)
| 18 | Normal DSU fails when the graph is directed to determine the redundant edges | - An edge case where you have the same target node for 2 nodes fails the DSU approach <br> - Process these edges after doing union of all the edges | [Redundant Connections II](./DSU/Redundant%20Connections%20II.py)


## Graph and Tree traversal learnings

| # | Summary | Comments | References |
|---|---------|----------|------------|
| 1 | Restarting the counts mid traversal | - Here, I was confused as to how to return the max value <br> - Though I could have updated the global max instead of returning it <br> - Most of the time, its easy to update the global value instead of returning the max value from the recursive function | [Longest Zigzag path in a Binary Tree](./Tree%20problems/Longest%20ZigZag%20Path%20in%20a%20Binary%20Tree.py)
| 2 | Postorder tree structure changes | - Think about postorder traversal when modification to the tree structure is required | [Flatten Binary Tree to Linked List](./BST%20problems/Flatten%20Binary%20Tree%20to%20Linked%20List.py)
| 3 | Exploring the grid using DFS <br> Finding the shortest path using BFS | - I tried finding the shortest path using DFS, lol me! <br> - Can't find the shortest path using DFS, can only use BFS <br> - Also, while doing BFS, add the nodes to the visited while exploring to save up space | [Shortest Path in a Hidden Grid](./BFS%20-%20DFS/Shortest%20Path%20in%20a%20Hidden%20Grid.py)
| 4 | A variation of DFS where direction can change only at the wall | - I should read and understand the question properly <br> - Direction could only change at the wall <br> - Also, the ball should have stopped at the destination | [The Maze](./BFS%20-%20DFS/The%20maze.py)
| 5 | If there are multiple entry points for BFS, <br>add all of them and do only one BFS | - In this problem, I did multiple BFS from all the entry points and added a condition that if the current cell val is greater than the new one, then only add it to the queue <br> - Instead, I could have added all the entry points to the queue and then done only one BFS | [Walls and Gates](./BFS%20-%20DFS/Walls%20and%20Gates.py)
| 6 | Always check the termnination condition and validity checks for BFS / DFS implementation | - These are the error prone areas while implementing BFS / DFS <br> - Termination condition check to see if the length calculation is correct <br> - Validity condition in exploration step to see if you are reaching the expected areas or not | [Shortest Bridge](./BFS%20-%20DFS/Shortest%20Bridge.py)
| 7 | Any problem which requires minimum number of steps could also be solved by BFS | - Coin change problem we know can be solved using DP easily <br> But I figured we can use a BFS strategy here as well | [Coin Change](./BFS%20-%20DFS/Coin%20Change.py)
| 8 | Sometimes, adding a parent pointer is useful | - Think about parent pointer when you really need to go up the tree | [All Nodes Distance K in Binary Tree](./BST%20problems/All%20Nodes%20Distance%20K%20in%20Binary%20Tree.py)


## Linked List traversal learnings
| # | Summary | Comments | References |
|---|---------|----------|------------|
| 1 | Choose the nodes based on the links to update | - Here, I had to update 3 links in a SLL <br> - I'll thus need 3 nodes, not two | [Swap nodes in pairs](./Linked%20Lists/Swap%20nodes%20in%20pairs.py)
| 2 | Halving, reversing rules | - After finding the middle element, if you have to halve the list, remember to set the next pointer of the first half to None <br> - Iterative reversing is better than recursion <br> - Always consider the edge cases of 1,2, even and odd elements | [Palindrome Linked List](./Linked%20Lists/Palindrome%20Linked%20List.py)
| 3 | For DLL, write create and delete Node functions | - create(val,after_node) and delete(node) functions make the implementation very easy <br> Whenever, you need a HashMap and not able to do some operations in O(1) with HashMap updates, think about DLL and the nodes in the values of the HashMap | [All O one Data Structure](./Linked%20Lists/All%20O%20one%20Data%20structure.py)